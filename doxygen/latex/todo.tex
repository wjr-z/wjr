\chapter{待办事项列表}
\hypertarget{todo}{}\label{todo}\index{待办事项列表@{待办事项列表}}

\begin{DoxyRefList}
\item[文件 \doxylink{biginteger_2biginteger_8hpp}{biginteger.hpp} ]\label{todo__todo000004}%
\Hypertarget{todo__todo000004}%

\begin{DoxyEnumerate}
\item Add more attributes to help the compiler optimize to zero overhead. Such as unsigned biginteger, fixed size biginteger.
\item Optimize reserve. For example, A = B + C, if A is restrict, then there\textquotesingle{}s no need to memcpy if A need to reserve.
\item Optimization of constant value.
\item \mbox{[}x\mbox{]} Use dispatch to optimize compile and binary size. 
\end{DoxyEnumerate}
\item[文件 \doxylink{btree_8hpp}{btree.hpp} ]\label{todo__todo000015}%
\Hypertarget{todo__todo000015}%

\begin{DoxyEnumerate}
\item Erase a range with optimization.
\item Construct with a range with optimization.
\item Merge with optimization.
\item \mbox{[}x\mbox{]} Code size optimization.
\item GCC optimization on unpacked struct failed?
\item Clang optimization on memcpy is so stupid.
\item MSVC bug on memcpy order (\href{https://developercommunity.visualstudio.com/t/incorrect-memcpy-optimization/1151407}{\texttt{ https\+://developercommunity.\+visualstudio.\+com/t/incorrect-\/memcpy-\/optimization/1151407}}).
\item \mbox{[}x\mbox{]} Optimization on small size.
\item Use a simple GC-\/arena to optimiza memory usage. 
\end{DoxyEnumerate}
\item[文件 \doxylink{copy_8hpp}{copy.hpp} ]\label{todo__todo000042}%
\Hypertarget{todo__todo000042}%
1. More fast small copy. 
\item[文件 \doxylink{document_8hpp}{document.hpp} ]\label{todo__todo000028}%
\Hypertarget{todo__todo000028}%
1. Optimization, separate document and element.
\begin{DoxyEnumerate}
\item Use flat\+\_\+map instead of std\+::map. 
\end{DoxyEnumerate}
\item[文件 \doxylink{huffman_8hpp}{huffman.hpp} ]\label{todo__todo000026}%
\Hypertarget{todo__todo000026}%
Not complete. 
\item[文件 \doxylink{large-compare-impl_8cpp}{large-\/compare-\/impl.cpp} ]\label{todo__todo000045}%
\Hypertarget{todo__todo000045}%
Support uint8\+\_\+t, uint16\+\_\+t, uint32\+\_\+t. 
\item[文件 \doxylink{large-find-impl_8cpp}{large-\/find-\/impl.cpp} ]\label{todo__todo000046}%
\Hypertarget{todo__todo000046}%
Support uint8\+\_\+t, uint16\+\_\+t, uint32\+\_\+t. 
\item[文件 \doxylink{memory__pool_8hpp}{memory\+\_\+pool.hpp} ]\label{todo__todo000043}%
\Hypertarget{todo__todo000043}%
Multithread memory pool. 
\item[文件 \doxylink{mod__34lsub1_8cpp}{mod\+\_\+34lsub1.cpp} ]\label{todo__todo000049}%
\Hypertarget{todo__todo000049}%
Assembly optimization. 
\item[文件 \doxylink{arch_2x86_2biginteger_2detail_2not_8hpp}{not.hpp} ]\label{todo__todo000002}%
\Hypertarget{todo__todo000002}%
Optimize... and move large builtin to .cpp. 
\item[文件 \doxylink{set_8cpp}{set.cpp} ]\label{todo__todo000047}%
\Hypertarget{todo__todo000047}%
1. Use streaming stores for large memory set ~\newline
 



2. Threshold for different SIMD and platform 
\item[文件 \doxylink{math_2set_8hpp}{set.hpp} ]\label{todo__todo000038}%
\Hypertarget{todo__todo000038}%
1. Using builtin\+\_\+memset on small size, and then fallback to my own large\+\_\+builtin\+\_\+memset or std\+::memset.
\begin{DoxyEnumerate}
\item Support stream load/store to optimize. 
\end{DoxyEnumerate}
\item[文件 \doxylink{shift_8cpp}{shift.cpp} ]\label{todo__todo000048}%
\Hypertarget{todo__todo000048}%
More optimization for some arch. Maybe only use SSE on AMD. 
\item[文件 \doxylink{arch_2x86_2simd_2simd_8hpp}{simd.hpp} ]\label{todo__todo000003}%
\Hypertarget{todo__todo000003}%
 
\item[文件 \doxylink{container_2vector_8hpp}{vector.hpp} ]\label{todo__todo000021}%
\Hypertarget{todo__todo000021}%

\begin{DoxyEnumerate}
\item small vector. Not in accordance with standards.
\item realloc. It is necessary for weak\+\_\+stack\+\_\+allcoator. Because this allocator can easily expand in place and do not clear any data.
\item take\+\_\+storage from init state? 
\end{DoxyEnumerate}
\item[文件 \doxylink{visitor_8hpp}{visitor.hpp} ]\label{todo__todo000032}%
\Hypertarget{todo__todo000032}%
\textbackslash{}
\begin{DoxyEnumerate}
\item Virtual visitor, this is faster than document. \textbackslash{}
\item Just like simdjson, parse struct by using iterator. In my test, \textbackslash{} this is slightly slower than first one.  
\end{DoxyEnumerate}
\item[类 \doxylink{classwjr_1_1arena}{wjr\+::arena} ]\label{todo__todo000041}%
\Hypertarget{todo__todo000041}%
Alignment ...  
\item[成员 \doxylink{classwjr_1_1basic__ring__buffer_a2c7edcb3a3031c5061db30c02fbe2ba7}{wjr\+::basic\+\_\+ring\+\_\+buffer\texorpdfstring{$<$}{<} Storage \texorpdfstring{$>$}{>}\+::operator=} (\doxylink{classwjr_1_1basic__ring__buffer}{basic\+\_\+ring\+\_\+buffer} \&\&other)=delete]\label{todo__todo000019}%
\Hypertarget{todo__todo000019}%
Complete.  
\item[成员 \doxylink{classwjr_1_1basic__ring__buffer_a53e05f2b30dbf931ff0a252d1e595830}{wjr\+::basic\+\_\+ring\+\_\+buffer\texorpdfstring{$<$}{<} Storage \texorpdfstring{$>$}{>}\+::operator=} (const \doxylink{classwjr_1_1basic__ring__buffer}{basic\+\_\+ring\+\_\+buffer} \&other)=delete]\label{todo__todo000018}%
\Hypertarget{todo__todo000018}%
Complete.  
\item[成员 \doxylink{classwjr_1_1basic__ring__buffer_a23be4831616b6a9e773830541a17b457}{wjr\+::basic\+\_\+ring\+\_\+buffer\texorpdfstring{$<$}{<} Storage \texorpdfstring{$>$}{>}\+::shrink\+\_\+to\+\_\+fit} ()]\label{todo__todo000020}%
\Hypertarget{todo__todo000020}%
designed shrink\+\_\+to\+\_\+fit for storage.  
\item[成员 \doxylink{classwjr_1_1basic__vector_a1b7729c372074f1c7a1a386a5d285b5b}{wjr\+::basic\+\_\+vector\texorpdfstring{$<$}{<} Storage \texorpdfstring{$>$}{>}\+::shrink\+\_\+to\+\_\+fit} ()]\label{todo__todo000023}%
\Hypertarget{todo__todo000023}%
designed shrink\+\_\+to\+\_\+fit for storage.  
\item[成员 \doxylink{classwjr_1_1bitset_a5ed9849798bf559fa4be3b04286ef759}{wjr\+::bitset\texorpdfstring{$<$}{<} N \texorpdfstring{$>$}{>}\+::operator\texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<}=} (size\+\_\+t offset) noexcept]\label{todo__todo000013}%
\Hypertarget{todo__todo000013}%
Use lshfit\+\_\+n to optimize.  
\item[成员 \doxylink{classwjr_1_1bitset_a278bc1e65695785643c828f49a058fa8}{wjr\+::bitset\texorpdfstring{$<$}{<} N \texorpdfstring{$>$}{>}\+::operator\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}=} (size\+\_\+t offset) noexcept]\label{todo__todo000014}%
\Hypertarget{todo__todo000014}%
Use rshfit\+\_\+n to optimize.  
\item[成员 \doxylink{namespacewjr_1_1constant_a76be3599673645166c966e9c5495a4ac}{wjr\+::constant\+::sort} (Iter first, Iter last, Pred pred)]\label{todo__todo000001}%
\Hypertarget{todo__todo000001}%
  
\item[成员 \doxylink{namespacewjr_a2ac368bf12ad574a2b044a57d4d7c64f}{wjr\+::div128by128to64} (\doxylink{classwjr_1_1uint128__t}{uint128\+\_\+t} \&rem, uint64\+\_\+t lo, uint64\+\_\+t hi, const div3by2\+\_\+divider$<$ uint64\+\_\+t $>$ \&divider) noexcept]\label{todo__todo000035}%
\Hypertarget{todo__todo000035}%
Using the {\ttfamily div} instruction directly on some machines may be faster  
\item[成员 \doxylink{namespacewjr_a122758d529da5743c56697211a29e473}{wjr\+::div128by64to128} (uint64\+\_\+t \&rem, uint64\+\_\+t lo, uint64\+\_\+t hi, uint64\+\_\+t div) noexcept]\label{todo__todo000034}%
\Hypertarget{todo__todo000034}%
Using the {\ttfamily div} instruction directly on some machines may be faster  
\item[成员 \doxylink{namespacewjr_a6b373ee33fd0a683a1ebbaebd3a1c63e}{wjr\+::div128by64to64} (uint64\+\_\+t \&rem, uint64\+\_\+t lo, uint64\+\_\+t hi, uint64\+\_\+t div) noexcept]\label{todo__todo000033}%
\Hypertarget{todo__todo000033}%
Using the {\ttfamily div} instruction directly on some machines may be faster  
\item[成员 \doxylink{structwjr_1_1get__relocate__mode_3_01small__vector__storage_3_01_t_00_01_capacity_00_01_alloc_01_4_01_4_aa677d71e831febe214c845f36f42a0f0}{wjr\+::get\+\_\+relocate\+\_\+mode\texorpdfstring{$<$}{<} small\+\_\+vector\+\_\+storage\texorpdfstring{$<$}{<} T, Capacity, Alloc \texorpdfstring{$>$}{>} \texorpdfstring{$>$}{>}\+::value} ]\label{todo__todo000022}%
\Hypertarget{todo__todo000022}%
May be trivial.  
\item[类 \doxylink{classwjr_1_1huffman__tree}{wjr\+::huffman\+\_\+tree\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}} ]\label{todo__todo000027}%
\Hypertarget{todo__todo000027}%
Allocator.  
\item[类 \doxylink{classwjr_1_1json_1_1basic__document}{wjr\+::json\+::basic\+\_\+document\texorpdfstring{$<$}{<} Traits \texorpdfstring{$>$}{>}} ]\label{todo__todo000029}%
\Hypertarget{todo__todo000029}%
1. For most strings, only need to check first character to compare.
\begin{DoxyEnumerate}
\item Maybe use hash like std\+::unordered\+\_\+map, but for long strings, compare even faster than hash.
\item In place construct without using low performance \doxylink{classwjr_1_1json_1_1basic__document}{basic\+\_\+document}. 
\end{DoxyEnumerate}
\item[成员 \doxylink{classwjr_1_1json_1_1basic__document_a24a32eb670abc7bf12682a8572aee254}{wjr\+::json\+::basic\+\_\+document\texorpdfstring{$<$}{<} Traits \texorpdfstring{$>$}{>}\+::\texorpdfstring{$\sim$}{\string~}basic\+\_\+document} () noexcept]\label{todo__todo000030}%
\Hypertarget{todo__todo000030}%
Optimize by not using recursion 
\item[成员 \doxylink{classwjr_1_1json_1_1lexer_aa176b548fb280c5522964954183ccc85}{wjr\+::json\+::lexer\+::read} (uint32\+\_\+t \texorpdfstring{$\ast$}{*}token\+\_\+buf, size\+\_\+type token\+\_\+buf\+\_\+size) noexcept]\label{todo__todo000044}%
\Hypertarget{todo__todo000044}%
Unroll two times maybe faster on some platforms.  
\item[成员 \doxylink{namespacewjr_a43054081d0310180521fc129593051a2}{wjr\+::operator\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}} (std\+::basic\+\_\+istream$<$ char, Traits $>$ \&is, basic\+\_\+biginteger$<$ S $>$ \&dst) noexcept]\label{todo__todo000007}%
\Hypertarget{todo__todo000007}%
Need to check when read string. But that\textquotesingle{}s so slow!  
\item[成员 \doxylink{namespacewjr_a4504e114cab4c369b5627018ea6d4e69}{wjr\+::powmod} (basic\+\_\+biginteger$<$ S $>$ \&dst, const \doxylink{structwjr_1_1biginteger__data}{biginteger\+\_\+data} \&num, uint64\+\_\+t exp, const \doxylink{structwjr_1_1biginteger__data}{biginteger\+\_\+data} \&mod) noexcept]\label{todo__todo000006}%
\Hypertarget{todo__todo000006}%
Need to optimize  
\item[成员 \doxylink{namespacewjr_a0af10ade61b607081bc1c95a4908a344}{wjr\+::powmod} (basic\+\_\+biginteger$<$ S $>$ \&dst, const \doxylink{structwjr_1_1biginteger__data}{biginteger\+\_\+data} \&num, const \doxylink{structwjr_1_1biginteger__data}{biginteger\+\_\+data} \&exp, const \doxylink{structwjr_1_1biginteger__data}{biginteger\+\_\+data} \&mod) noexcept]\label{todo__todo000005}%
\Hypertarget{todo__todo000005}%
Need to optimize  
\item[成员 \doxylink{namespacewjr_a38479686b930cd6c122aedaa7f6ceed8}{wjr\+::replace\+\_\+find\+\_\+not} (T \texorpdfstring{$\ast$}{*}dst, const T \texorpdfstring{$\ast$}{*}src, size\+\_\+t n, type\+\_\+identity\+\_\+t$<$ T $>$ from, type\+\_\+identity\+\_\+t$<$ T $>$ to) noexcept]\label{todo__todo000037}%
\Hypertarget{todo__todo000037}%
Optimization, merge builtin\+\_\+find\+\_\+not\+\_\+n and builtin\+\_\+set\+\_\+n. 
\item[成员 \doxylink{namespacewjr_ad8de527075ad6762c54d1237bcd8b72d}{wjr\+::set\+\_\+n} (T \texorpdfstring{$\ast$}{*}dst, type\+\_\+identity\+\_\+t$<$ T $>$ val, size\+\_\+t n) noexcept]\label{todo__todo000039}%
\Hypertarget{todo__todo000039}%
Tests for T = uint16\+\_\+t/uint32\+\_\+t when using builtin\+\_\+set\+\_\+n.  
\item[类 \doxylink{classwjr_1_1uint128__t}{wjr\+::uint128\+\_\+t} ]\label{todo__todo000040}%
\Hypertarget{todo__todo000040}%
implement more functions
\end{DoxyRefList}